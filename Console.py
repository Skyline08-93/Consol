# triangle_bybit_bot.py ‚Äî –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–æ—Ä–≥–æ–≤—ã–π –±–æ—Ç –¥–ª—è Bybit
import ccxt.async_support as ccxt
import asyncio
import os
import hashlib
import time
import logging
from datetime import datetime, timedelta
from telegram import Bot
from telegram.constants import ParseMode
from telegram.ext import Application

# === –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ===
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("bot_debug.log")
    ]
)
logger = logging.getLogger('TriangleBot')
logger.setLevel(logging.DEBUG if os.getenv("DEBUG") else logging.INFO)

# === –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –æ–∫—Ä—É–∂–µ–Ω–∏—è ===
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
API_KEY = os.getenv("BYBIT_API_KEY")
API_SECRET = os.getenv("BYBIT_API_SECRET")
IS_TESTNET = os.getenv("TESTNET", "false").lower() == "true"

# === –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–æ—Ä–≥–æ–≤–ª–∏ ===
COMMISSION_RATE = 0.001  # 0.1%
MIN_PROFIT = 0.15  # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥ –ø—Ä–∏–±—ã–ª–∏
MAX_PROFIT = 2.0   # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥ –ø—Ä–∏–±—ã–ª–∏
TARGET_VOLUME_USDT = float(os.getenv("TRADE_VOLUME", "10"))
START_COINS = ['USDT', 'BTC', 'ETH']
LOG_FILE = "trades.csv"
MAX_SLIPPAGE = 0.005  # 0.5%
MAX_RETRIES = 3
RETRY_DELAY = 1.5
MAX_CONCURRENT_TRADES = 1
MIN_BALANCE_USDT = 15

# === –ó–∞—â–∏—Ç–Ω—ã–µ –º–µ—Ö–∞–Ω–∏–∑–º—ã ===
TRADE_COOLDOWN = timedelta(minutes=5)
BALANCE_REFRESH_INTERVAL = 3600  # 1 —á–∞—Å
SYMBOL_REFRESH_INTERVAL = 86400  # 1 –¥–µ–Ω—å
TRIANGLE_HOLD_TIME = 10  # —Å–µ–∫—É–Ω–¥

# === –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è ===
active_trades = {}
last_trade_time = {}
symbols_cache = {}
markets_cache = {}
triangles_cache = []
last_symbol_refresh = 0
last_balance_refresh = 0
current_balances = {}

# === –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∏—Ä–∂–∏ ===
def init_exchange():
    exchange_options = {
        "enableRateLimit": True,
        "apiKey": API_KEY,
        "secret": API_SECRET,
        "options": {"defaultType": "spot"}
    }
    
    if IS_TESTNET:
        exchange_options["urls"] = {
            "api": {"public": "https://api-testnet.bybit.com", 
                    "private": "https://api-testnet.bybit.com"}
        }
        logger.info("–†–µ–∂–∏–º –¢–ï–°–¢–û–í–û–ô –°–ï–¢–ò –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω")
    else:
        logger.info("–†–µ–∂–∏–º –†–ï–ê–õ–¨–ù–û–ô –°–ï–¢–ò –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω")
    
    return ccxt.bybit(exchange_options)

exchange = init_exchange()

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ñ–∞–π–ª–∞ –ª–æ–≥–∞
if not os.path.exists(LOG_FILE):
    with open(LOG_FILE, "w") as f:
        f.write("timestamp,route,profit_percent,volume_usdt,status,details\n")

async def refresh_symbols(force=False):
    global symbols_cache, markets_cache, triangles_cache, last_symbol_refresh
    
    current_time = time.time()
    if not force and current_time - last_symbol_refresh < SYMBOL_REFRESH_INTERVAL:
        return symbols_cache, markets_cache, triangles_cache
    
    try:
        logger.debug("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä...")
        markets = await exchange.load_markets()
        symbols = list(markets.keys())
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–µ—à–µ–π
        symbols_cache = symbols
        markets_cache = markets
        triangles_cache = await find_triangles(symbols)
        last_symbol_refresh = current_time
        
        logger.info(f"–û–±–Ω–æ–≤–ª–µ–Ω–æ {len(symbols)} –ø–∞—Ä, –Ω–∞–π–¥–µ–Ω–æ {len(triangles_cache)} —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤")
        return symbols_cache, markets_cache, triangles_cache
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–∞—Ä: {str(e)}")
        return symbols_cache, markets_cache, triangles_cache

async def find_triangles(symbols):
    triangles = []
    for base in START_COINS:
        for sym1 in symbols:
            if not sym1.endswith('/' + base): 
                continue
            mid1 = sym1.split('/')[0]
            for sym2 in symbols:
                if not sym2.startswith(mid1 + '/'): 
                    continue
                mid2 = sym2.split('/')[1]
                third = f"{mid2}/{base}"
                if third in symbols:
                    triangles.append((base, mid1, mid2))
    return triangles

async def get_avg_price(orderbook_side, target_usdt):
    total_base = 0
    total_usd = 0
    max_liquidity = 0
    
    for price, volume in orderbook_side:
        price = float(price)
        volume = float(volume)
        usd = price * volume
        max_liquidity += usd
        
        if total_usd + usd >= target_usdt:
            remain_usd = target_usdt - total_usd
            total_base += remain_usd / price
            total_usd += remain_usd
            break
        else:
            total_base += volume
            total_usd += usd
    
    if total_usd < target_usdt * 0.9:  # –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–∞—è –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å
        return None, 0, max_liquidity
    
    avg_price = total_usd / total_base
    return avg_price, total_usd, max_liquidity

async def get_execution_price(symbol, side, target_usdt):
    for attempt in range(MAX_RETRIES):
        try:
            orderbook = await exchange.fetch_order_book(symbol, limit=20)
            if side == "buy":
                return await get_avg_price(orderbook['asks'], target_usdt)
            else:
                return await get_avg_price(orderbook['bids'], target_usdt)
        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ —Å—Ç–∞–∫–∞–Ω–∞ {symbol} (–ø–æ–ø—ã—Ç–∫–∞ {attempt+1}): {str(e)}")
            await asyncio.sleep(RETRY_DELAY)
    
    return None, 0, 0

def format_line(index, pair, price, side, volume_usd, color, liquidity):
    emoji = {"green": "üü¢", "yellow": "üü°", "red": "üî¥"}.get(color, "")
    return f"{emoji} {index}. {pair} - {price:.6f} ({side}), –∏—Å–ø–æ–ª–Ω–µ–Ω–æ ${volume_usd:.2f}, –¥–æ—Å—Ç—É–ø–Ω–æ ${liquidity:.2f}"

async def send_telegram_message(text, important=False):
    if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:
        return
    
    try:
        await telegram_app.bot.send_message(
            chat_id=TELEGRAM_CHAT_ID, 
            text=text, 
            parse_mode=ParseMode.HTML,
            disable_web_page_preview=True
        )
    except Exception as e:
        if important:
            logger.error(f"–û—à–∏–±–∫–∞ Telegram: {str(e)}")

def log_trade(base, mid1, mid2, profit, volume, status, details=""):
    try:
        with open(LOG_FILE, "a") as f:
            route = f"{base}->{mid1}->{mid2}->{base}"
            f.write(f"{datetime.utcnow()},{route},{profit:.4f},{volume},{status},{details}\n")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ –ª–æ–≥–∞: {str(e)}")

async def refresh_balances(force=False):
    global current_balances, last_balance_refresh
    
    current_time = time.time()
    if not force and current_time - last_balance_refresh < BALANCE_REFRESH_INTERVAL:
        return current_balances
    
    try:
        logger.debug("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–æ–≤...")
        balances = await exchange.fetch_balance()
        current_balances = {k: float(v) for k, v in balances["total"].items() if float(v) > 0}
        last_balance_refresh = current_time
        
        # –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø—Ä–∏ –Ω–∏–∑–∫–æ–º –±–∞–ª–∞–Ω—Å–µ
        usdt_balance = current_balances.get('USDT', 0)
        if usdt_balance < MIN_BALANCE_USDT:
            msg = f"‚ö†Ô∏è <b>–ù–ò–ó–ö–ò–ô –ë–ê–õ–ê–ù–°!</b> ‚ö†Ô∏è\nUSDT: {usdt_balance:.2f} < {MIN_BALANCE_USDT}"
            await send_telegram_message(msg, important=True)
        
        return current_balances
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –±–∞–ª–∞–Ω—Å–∞: {str(e)}")
        return current_balances

def can_execute_trade(route_id):
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–¥–µ–ª–æ–∫
    if len(active_trades) >= MAX_CONCURRENT_TRADES:
        logger.warning(f"–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–¥–µ–ª–æ–∫: {route_id}")
        return False
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–¥–µ–ª–∫–∏
    last_time = last_trade_time.get(route_id)
    if last_time and (datetime.utcnow() - last_time) < TRADE_COOLDOWN:
        logger.debug(f"–¢–æ—Ä–≥–æ–≤–ª—è –≤ —Ä–µ–∂–∏–º–µ –æ—Ö–ª–∞–∂–¥–µ–Ω–∏—è: {route_id}")
        return False
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞ USDT
    usdt_balance = current_balances.get('USDT', 0)
    if usdt_balance < TARGET_VOLUME_USDT * 1.1:
        logger.warning(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–π –±–∞–ª–∞–Ω—Å USDT: {usdt_balance:.2f} < {TARGET_VOLUME_USDT * 1.1:.2f}")
        return False
    
    return True

async def execute_real_trade(route_id, steps):
    """–í—ã–ø–æ–ª–Ω—è–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–µ —Ç–æ—Ä–≥–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏"""
    # –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –º–∞—Ä—à—Ä—É—Ç–∞
    active_trades[route_id] = datetime.utcnow()
    
    trade_details = []
    try:
        for i, (symbol, side, amount) in enumerate(steps):
            logger.info(f"–ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞ {i+1}/{len(steps)}: {symbol} {side} {amount:.6f}")
            
            # –°–æ–∑–¥–∞–Ω–∏–µ —Ä—ã–Ω–æ—á–Ω–æ–≥–æ –æ—Ä–¥–µ—Ä–∞
            order = await exchange.create_order(
                symbol=symbol,
                type='market',
                side=side,
                amount=amount,
                params={'timeInForce': 'IOC'}
            )
            trade_details.append(order)
            
            # –ö—Ä–∞—Ç–∫–∞—è –ø–∞—É–∑–∞ –º–µ–∂–¥—É –æ—Ä–¥–µ—Ä–∞–º–∏
            if i < len(steps) - 1:
                await asyncio.sleep(0.7)
                
        return True, trade_details
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–¥–µ–ª–∫–∏: {str(e)}")
        return False, str(e)
    finally:
        # –°–Ω—è—Ç–∏–µ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
        active_trades.pop(route_id, None)
        last_trade_time[route_id] = datetime.utcnow()

async def check_triangle(base, mid1, mid2, symbols, markets):
    try:
        route_id = f"{base}->{mid1}->{mid2}->{base}"
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –º–∞—Ä—à—Ä—É—Ç–∞
        s1 = f"{mid1}/{base}"
        s2 = f"{mid2}/{mid1}"
        s3 = f"{mid2}/{base}"
        
        if not (s1 in symbols and s2 in symbols and s3 in symbols):
            return
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –æ–±—ä–µ–º–∞
        market_info = markets.get(s1)
        if market_info and 'limits' in market_info:
            min_amount = market_info['limits']['amount']['min']
            if TARGET_VOLUME_USDT < min_amount * 10:  # 10x –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –æ–±—ä–µ–º–∞
                return

        # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ü–µ–Ω –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
        price1, vol1, liq1 = await get_execution_price(s1, "buy", TARGET_VOLUME_USDT)
        if not price1 or vol1 < TARGET_VOLUME_USDT * 0.8:
            return
            
        price2, vol2, liq2 = await get_execution_price(s2, "buy", vol1 * 0.99)
        if not price2:
            return
            
        price3, vol3, liq3 = await get_execution_price(s3, "sell", vol2 * 0.99)
        if not price3:
            return

        # –†–∞—Å—á–µ—Ç –ø—Ä–∏–±—ã–ª–∏ —Å —É—á–µ—Ç–æ–º –∫–æ–º–∏—Å—Å–∏–π
        step1 = (1 / price1) * (1 - COMMISSION_RATE)
        step2 = step1 * (1 / price2) * (1 - COMMISSION_RATE)
        step3 = step2 * price3 * (1 - COMMISSION_RATE)
        
        profit_percent = (step3 - 1) * 100
        if not (MIN_PROFIT <= profit_percent <= MAX_PROFIT): 
            return

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π –¥–ª—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
        if not can_execute_trade(route_id):
            return

        min_liquidity = min(liq1, liq2, liq3)
        pure_profit_usdt = (step3 - 1) * TARGET_VOLUME_USDT

        # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        message_lines = [
            f"üîÅ <b>–ê—Ä–±–∏—Ç—Ä–∞–∂–Ω–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å</b>",
            format_line(1, s1, price1, "ASK", vol1, "green", liq1),
            format_line(2, s2, price2, "ASK", vol2, "yellow", liq2),
            format_line(3, s3, price3, "BID", vol3, "red", liq3),
            "",
            f"üí∞ <b>–ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å:</b> {pure_profit_usdt:.2f} USDT",
            f"üìà <b>–°–ø—Ä–µ–¥:</b> {profit_percent:.2f}%",
            f"üíß <b>–ú–∏–Ω. –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å:</b> ${min_liquidity:.2f}"
        ]

        # –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ Telegram
        await send_telegram_message("\n".join(message_lines))
        log_trade(base, mid1, mid2, profit_percent, min_liquidity, "detected")

        # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —à–∞–≥–æ–≤ —Å–¥–µ–ª–∫–∏
        steps = [
            (s1, "buy", TARGET_VOLUME_USDT),
            (s2, "buy", TARGET_VOLUME_USDT / price1 * (1 - COMMISSION_RATE)),
            (s3, "sell", TARGET_VOLUME_USDT / price1 / price2 * (1 - 2*COMMISSION_RATE))
        ]

        # –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Å–¥–µ–ª–∫–∏
        trade_success, trade_result = await execute_real_trade(route_id, steps)
        
        if trade_success:
            profit_msg = f"‚úÖ <b>–°–¥–µ–ª–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞</b>\n–ü—Ä–∏–±—ã–ª—å: {pure_profit_usdt:.2f} USDT ({profit_percent:.2f}%)"
            await send_telegram_message(profit_msg, important=True)
            log_trade(base, mid1, mid2, profit_percent, TARGET_VOLUME_USDT, "executed", str(trade_result))
        else:
            error_msg = f"‚ùå <b>–û—à–∏–±–∫–∞ —Å–¥–µ–ª–∫–∏</b>\n{str(trade_result)[:200]}"
            await send_telegram_message(error_msg, important=True)
            log_trade(base, mid1, mid2, profit_percent, TARGET_VOLUME_USDT, "failed", str(trade_result))
            
        # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –ø–æ—Å–ª–µ —Å–¥–µ–ª–∫–∏
        await refresh_balances(force=True)
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞: {str(e)}", exc_info=True)
        error_msg = f"‚ö†Ô∏è <b>–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏</b>\n{str(e)[:100]}"
        await send_telegram_message(error_msg, important=True)

async def send_balance_update():
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å –≤ Telegram"""
    try:
        balances = await refresh_balances()
        if not balances:
            return
            
        msg = ["üí∞ <b>–ë–ê–õ–ê–ù–°:</b>"]
        for coin, amount in balances.items():
            if amount > 0.001:  # –§–∏–ª—å—Ç—Ä –º–∞–ª—ã—Ö —Å—É–º–º
                msg.append(f"{coin}: {amount:.6f}")
        
        await send_telegram_message("\n".join(msg))
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –±–∞–ª–∞–Ω—Å–∞: {str(e)}")

async def check_exchange_connection():
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∏—Ä–∂–µ"""
    try:
        await exchange.fetch_time()
        return True
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {str(e)}")
        error_msg = f"‚ùå <b>–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Bybit</b>\n{str(e)[:200]}"
        await send_telegram_message(error_msg, important=True)
        return False

async def safe_shutdown():
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã"""
    logger.info("–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã...")
    try:
        await exchange.close()
        await telegram_app.stop()
        await telegram_app.shutdown()
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è: {str(e)}")
    finally:
        logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

async def main_loop():
    """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞"""
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram
    global telegram_app
    telegram_app = Application.builder().token(TELEGRAM_TOKEN).build()
    await telegram_app.initialize()
    await telegram_app.start()
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
    if not await check_exchange_connection():
        await safe_shutdown()
        return
    
    # –ù–∞—á–∞–ª—å–Ω—ã–µ –∑–∞–≥—Ä—É–∑–∫–∏
    await send_telegram_message("ü§ñ <b>–¢–æ—Ä–≥–æ–≤—ã–π –±–æ—Ç –∑–∞–ø—É—â–µ–Ω</b>")
    await refresh_symbols(force=True)
    await refresh_balances(force=True)
    
    # –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
    logger.info("–ù–∞—á–∞–ª–æ —Ä–∞–±–æ—Ç—ã –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ü–∏–∫–ª–∞")
    last_balance_update = time.time()
    
    while True:
        try:
            # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            current_time = time.time()
            if current_time - last_balance_update > BALANCE_REFRESH_INTERVAL:
                await refresh_balances()
                last_balance_update = current_time
            
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤
            symbols, markets, triangles = await refresh_symbols()
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤
            tasks = [check_triangle(base, mid1, mid2, symbols, markets) 
                     for base, mid1, mid2 in triangles]
            await asyncio.gather(*tasks)
                
            await asyncio.sleep(8)
            
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≥–ª–∞–≤–Ω–æ–≥–æ —Ü–∏–∫–ª–∞: {str(e)}", exc_info=True)
            await asyncio.sleep(30)

async def main():
    try:
        await main_loop()
    except KeyboardInterrupt:
        logger.info("–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è")
    finally:
        await safe_shutdown()

if __name__ == '__main__':
    asyncio.run(main())